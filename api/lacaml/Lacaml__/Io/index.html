<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Io (lacaml.Lacaml__.Io)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">lacaml</a> &#x00BB; <a href="../index.html">Lacaml__</a> &#x00BB; Io</nav><h1>Module <code>Lacaml__.Io</code></h1><nav class="toc"><ul><li><a href="#default-pretty-printers-used-by-the-other-pretty-printing-functions">Default pretty-printers used by the other pretty-printing functions</a></li><li><a href="#pretty-printing-in-standard-style">Pretty-printing in standard style</a></li><li><a href="#labeled-pretty-printing">Labeled pretty-printing</a></li><li><a href="#vectors">Vectors</a></li><li><a href="#matrices">Matrices</a></li><li><a href="#pretty-printing-in-ocaml-style">Pretty-printing in OCaml-style</a></li><li><a href="#good-pretty-printers-for-toplevels">Good pretty-printers for toplevels</a></li></ul></nav></header><aside><p><code>Lacaml.Io</code>: generic matrix printing functions.</p></aside><div class="spec module" id="module-Context"><a href="#module-Context" class="anchor"></a><code><span class="keyword">module</span> <a href="Context/index.html">Context</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pp_mat_gen"><a href="#val-pp_mat_gen" class="anchor"></a><code><span class="keyword">val</span> pp_mat_gen : <span>?&#8288;pp_open:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_close:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_head:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_foot:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_end_row:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_end_col:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span>row:int</span> <span>&#45;&gt;</span> <span>col:int</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_left:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_right:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pad:<span>char option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ellipsis:string</span> <span>&#45;&gt;</span> <span>?&#8288;vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'el</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'a</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array2.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_mat_gen
       ?pp_open ?pp_close ?pp_head ?pp_foot ?pp_end_row ?pp_end_col
       ?pp_left ?pp_right ?pad pp_el ppf mat</code></p><p>Generic printing of matrices (two-dimensional bigarrays).</p><p><code>pp_open ppf</code> is called whenever printing of a matrix <code>mat</code> is started, <code>pp_close ppf</code> whenever printing is complete. These functions are not called when the matrix is empty.</p><p><code>pp_head other_ppf col</code> is used to print a header for column <code>col</code> in matrix <code>mat</code>. This header is right-aligned and eventually padded using <code>Some pad</code>-character to match the matrix rows in the column beneath. The passed formatter <code>other_ppf</code> is not identical to <code>ppf</code>!</p><p><code>pp_foot other_ppf col</code> is used to print a footer for column <code>col</code> in matrix <code>mat</code>. It is similar to <code>pp_head col other_ppf</code> otherwise.</p><p><code>pp_end_row ppf row</code> is called on row number <code>row</code> and formatter <code>ppf</code> whenever the end of a row has been reached.</p><p><code>pp_end_col ppf ~row ~col</code> is called on the row number <code>row</code>, column number <code>col</code> and formatter <code>ppf</code> whenever the element at this position has been printed and if it is not the last element in the row.</p><p><code>pp_left ppf row</code> is called on row number <code>row</code> and formatter <code>ppf</code> to print labels to the left of each row. The labels are right-aligned within a virtual column.</p><p><code>pp_right ppf row</code> is called on row number <code>row</code> and formatter <code>ppf</code> to print labels to the right of each row. The labels are left-aligned.</p><p>The character <code>pad</code> is used to pad matrix elements for right-aligning them appropriately. If it is set to <code>None</code>, no alignment will be performed.</p><p><code>ellipsis</code> is used as a filler when elements need to be skipped in the case of printing with contexts.</p><p><code>vertical_context</code> determines the number of initial and final rows to be printed. Intermediate row will be skipped, and one row containing ellipsis elements will be printed in their place instead. <code>None</code> chooses no context, <code>Some v</code> sets the vertical context to <code>v</code>.</p><p><code>horizontal_context</code> determines the number of initial and final columns to be printed. Intermediate columns will be skipped, and one columns containing ellipsis elements will be printed in their place instead. <code>None</code> chooses no context, <code>Some h</code> sets the horizontal context to <code>h</code>.</p><p><code>pp_el other_ppf el</code> is called on formatter <code>other_ppf</code> (not <code>ppf</code>!) and each matrix element.</p><p><code>ppf</code> is the formatter to which all output is finally printed.</p><p><code>mat</code> is the matrix to be printed.</p><dl><dt>parameter pp_open</dt><dd><p>default = open standard pretty-printing box</p></dd></dl><dl><dt>parameter pp_close</dt><dd><p>default = close standard pretty-printing box</p></dd></dl><dl><dt>parameter pp_head</dt><dd><p>default = no default</p></dd></dl><dl><dt>parameter pp_foot</dt><dd><p>default = no default</p></dd></dl><dl><dt>parameter pp_end_row</dt><dd><p>default = print newline (within pretty-printing box)</p></dd></dl><dl><dt>parameter pp_end_col</dt><dd><p>default = print space</p></dd></dl><dl><dt>parameter pp_left</dt><dd><p>default = no default</p></dd></dl><dl><dt>parameter pad</dt><dd><p>default = <code>Some ' '</code></p></dd></dl><dl><dt>parameter ellipsis</dt><dd><p>default = <code>!Context.ellipsis</code></p></dd></dl><dl><dt>parameter vertical_context</dt><dd><p>default = <code>Some !Context.vertical_default</code></p></dd></dl><dl><dt>parameter horizontal_context</dt><dd><p>default = <code>Some !Context.horizontal_default</code></p></dd></dl></dd></dl><section><header><h6 id="default-pretty-printers-used-by-the-other-pretty-printing-functions"><a href="#default-pretty-printers-used-by-the-other-pretty-printing-functions" class="anchor"></a>Default pretty-printers used by the other pretty-printing functions</h6></header><dl><dt class="spec type" id="type-pp_el_default"><a href="#type-pp_el_default" class="anchor"></a><code><span class="keyword">type</span> <span>'el pp_el_default</span></code><code> = <span><span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'el</span> <span>&#45;&gt;</span> unit)</span> Stdlib.ref</span></code></dt><dd><p>Type of references for default printers of elements</p></dd></dl><dl><dt class="spec value" id="val-pp_float_el_default"><a href="#val-pp_float_el_default" class="anchor"></a><code><span class="keyword">val</span> pp_float_el_default : <span>float <a href="index.html#type-pp_el_default">pp_el_default</a></span></code></dt><dd><p>fprintf ppf &quot;%G&quot; el</p></dd></dl><dl><dt class="spec value" id="val-pp_complex_el_default"><a href="#val-pp_complex_el_default" class="anchor"></a><code><span class="keyword">val</span> pp_complex_el_default : <span>Stdlib.Complex.t <a href="index.html#type-pp_el_default">pp_el_default</a></span></code></dt><dd><p>fprintf ppf &quot;(%G, %Gi)&quot; el.re el.im</p></dd></dl><dl><dt class="spec value" id="val-pp_int32_el"><a href="#val-pp_int32_el" class="anchor"></a><code><span class="keyword">val</span> pp_int32_el : Stdlib.Format.formatter <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> unit</code></dt><dd><p>fprintf ppf &quot;%ld&quot; el</p></dd></dl></section><section><header><h6 id="pretty-printing-in-standard-style"><a href="#pretty-printing-in-standard-style" class="anchor"></a>Pretty-printing in standard style</h6></header><dl><dt class="spec type" id="type-pp_vec"><a href="#type-pp_vec" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_vec</span></code><code> = Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array1.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of standard pretty-printers for column vectors</p><p><code>pp_vec ppf vec</code> prints a vector <code>vec</code> to formatter <code>ppf</code> using the defaults.</p></dd></dl><dl><dt class="spec value" id="val-pp_fvec"><a href="#val-pp_fvec" class="anchor"></a><code><span class="keyword">val</span> pp_fvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_vec">pp_vec</a></span></code></dt><dt class="spec value" id="val-pp_cvec"><a href="#val-pp_cvec" class="anchor"></a><code><span class="keyword">val</span> pp_cvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_vec">pp_vec</a></span></code></dt><dt class="spec value" id="val-pp_ivec"><a href="#val-pp_ivec" class="anchor"></a><code><span class="keyword">val</span> pp_ivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_vec">pp_vec</a></span></code></dt><dt class="spec value" id="val-pp_rfvec"><a href="#val-pp_rfvec" class="anchor"></a><code><span class="keyword">val</span> pp_rfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_vec">pp_vec</a></span></code></dt><dt class="spec value" id="val-pp_rcvec"><a href="#val-pp_rcvec" class="anchor"></a><code><span class="keyword">val</span> pp_rcvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_vec">pp_vec</a></span></code></dt><dt class="spec value" id="val-pp_rivec"><a href="#val-pp_rivec" class="anchor"></a><code><span class="keyword">val</span> pp_rivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_vec">pp_vec</a></span></code></dt></dl><dl><dt class="spec type" id="type-pp_mat"><a href="#type-pp_mat" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_mat</span></code><code> = Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array2.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of standard pretty-printers for matrices</p><p><code>pp_mat ppf mat</code> prints a matrix <code>mat</code> to formatter <code>ppf</code> using the defaults.</p></dd></dl><dl><dt class="spec value" id="val-pp_fmat"><a href="#val-pp_fmat" class="anchor"></a><code><span class="keyword">val</span> pp_fmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_mat">pp_mat</a></span></code></dt><dt class="spec value" id="val-pp_cmat"><a href="#val-pp_cmat" class="anchor"></a><code><span class="keyword">val</span> pp_cmat : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_mat">pp_mat</a></span></code></dt><dt class="spec value" id="val-pp_imat"><a href="#val-pp_imat" class="anchor"></a><code><span class="keyword">val</span> pp_imat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_mat">pp_mat</a></span></code></dt></dl></section><section><header><h6 id="labeled-pretty-printing"><a href="#labeled-pretty-printing" class="anchor"></a>Labeled pretty-printing</h6></header></section><section><header><h6 id="vectors"><a href="#vectors" class="anchor"></a>Vectors</h6></header><dl><dt class="spec type" id="type-pp_labeled_vec"><a href="#type-pp_labeled_vec" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_labeled_vec</span></code><code> = <span>?&#8288;pp_head:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_foot:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_left:<span><span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_right:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pad:<span>char option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ellipsis:string</span> <span>&#45;&gt;</span> <span>?&#8288;vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array1.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of pretty-printers for labeled vectors</p><p><code>pp_labeled_vec ?pp_head ?pp_foot ?pp_left ?pp_right ?pad
      ?ellipsis ?vertical_context ?horizontal_context () ppf vec</code> prints vector <code>vec</code> to formatter <code>ppf</code> labeling the header using function <code>pp_head</code>, the footer using <code>pp_foot</code>, the left side (of rows for column vectors; of columns for row vectors) using <code>pp_left</code>, and the right side using <code>pp_right</code>. A <code>pad</code>-option and context options can be passed.</p><p>For column vectors the labels on the left side are right-aligned while those on the right side are left-aligned.</p><dl><dt>parameter pp_head</dt><dd><p>default = no default (= no printing)</p></dd></dl><dl><dt>parameter pp_foot</dt><dd><p>default = no default (= no printing)</p></dd></dl><dl><dt>parameter pp_left</dt><dd><p>default = <code>Some pp_int32_el</code> for vector rows/cols (= not in header/footer row/col)</p></dd></dl><dl><dt>parameter pp_right</dt><dd><p>default = no default (= no printing)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_labeled_fvec"><a href="#val-pp_labeled_fvec" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_fvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_vec">pp_labeled_vec</a></span></code></dt><dt class="spec value" id="val-pp_labeled_cvec"><a href="#val-pp_labeled_cvec" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_cvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_vec">pp_labeled_vec</a></span></code></dt><dt class="spec value" id="val-pp_labeled_ivec"><a href="#val-pp_labeled_ivec" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_ivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_vec">pp_labeled_vec</a></span></code></dt><dt class="spec value" id="val-pp_labeled_rfvec"><a href="#val-pp_labeled_rfvec" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_rfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_vec">pp_labeled_vec</a></span></code></dt><dt class="spec value" id="val-pp_labeled_rcvec"><a href="#val-pp_labeled_rcvec" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_rcvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_vec">pp_labeled_vec</a></span></code></dt><dt class="spec value" id="val-pp_labeled_rivec"><a href="#val-pp_labeled_rivec" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_rivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_vec">pp_labeled_vec</a></span></code></dt></dl><dl><dt class="spec type" id="type-pp_lvec"><a href="#type-pp_lvec" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_lvec</span></code><code> = <span>?&#8288;print_head:bool</span> <span>&#45;&gt;</span> <span>?&#8288;print_foot:bool</span> <span>&#45;&gt;</span> <span>?&#8288;print_left:bool</span> <span>&#45;&gt;</span> <span>?&#8288;print_right:bool</span> <span>&#45;&gt;</span> <span>?&#8288;labels:<span>string array</span></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <span>?&#8288;pad:<span>char option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ellipsis:string</span> <span>&#45;&gt;</span> <span>?&#8288;vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array1.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of pretty-printers for string labeled vectors</p><p><code>pp_lvec ?print_head ?print_foot ?print_left ?print_right
      ?labels ?name ?pad ?ellipsis ?vertical_context ?horizontal_context
      () ppf vec</code> prints vector <code>vec</code> to formatter <code>ppf</code> labeling the header with <code>name</code> if provided and if <code>print_head</code> is true, and labeling the footer with <code>name</code> if <code>print_foot</code> is true. The left side (of rows for column vectors; of columns for row vectors) is labeled with <code>labels</code> if provided and if <code>print_left</code> is true, and the right side is labeled with <code>labels</code> if <code>print_right</code> is true. A <code>pad</code>-option and context options can be passed.</p><p>For columns vectors the labels on the left side are right-aligned while those on the right side are left-aligned.</p><p>It is the duty of the user to make sure that the array containing the labels is sufficiently large for the given vector.</p><dl><dt>parameter print_head</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter print_foot</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter print_left</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter print_right</dt><dd><p>default = <code>false</code></p></dd></dl><dl><dt>parameter labels</dt><dd><p>default = no default (= no printing)</p></dd></dl><dl><dt>parameter header</dt><dd><p>default = no default (= no printing)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_lfvec"><a href="#val-pp_lfvec" class="anchor"></a><code><span class="keyword">val</span> pp_lfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lvec">pp_lvec</a></span></code></dt><dt class="spec value" id="val-pp_lcvec"><a href="#val-pp_lcvec" class="anchor"></a><code><span class="keyword">val</span> pp_lcvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lvec">pp_lvec</a></span></code></dt><dt class="spec value" id="val-pp_livec"><a href="#val-pp_livec" class="anchor"></a><code><span class="keyword">val</span> pp_livec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lvec">pp_lvec</a></span></code></dt><dt class="spec value" id="val-pp_rlfvec"><a href="#val-pp_rlfvec" class="anchor"></a><code><span class="keyword">val</span> pp_rlfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lvec">pp_lvec</a></span></code></dt><dt class="spec value" id="val-pp_rlcvec"><a href="#val-pp_rlcvec" class="anchor"></a><code><span class="keyword">val</span> pp_rlcvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lvec">pp_lvec</a></span></code></dt><dt class="spec value" id="val-pp_rlivec"><a href="#val-pp_rlivec" class="anchor"></a><code><span class="keyword">val</span> pp_rlivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lvec">pp_lvec</a></span></code></dt></dl></section><section><header><h6 id="matrices"><a href="#matrices" class="anchor"></a>Matrices</h6></header><dl><dt class="spec type" id="type-pp_labeled_mat"><a href="#type-pp_labeled_mat" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_labeled_mat</span></code><code> = <span>?&#8288;pp_head:<span><span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_foot:<span><span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_left:<span><span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_right:<span><span>(Stdlib.Format.formatter <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit)</span> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;pad:<span>char option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ellipsis:string</span> <span>&#45;&gt;</span> <span>?&#8288;vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array2.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of pretty-printers for labeled matrices</p><p><code>pp_labeled_mat ?pp_head ?pp_foot ?pp_left ?pp_right ?pad
      ?ellipsis ?vertical_context ?horizontal_context () ppf mat</code> prints a matrix <code>mat</code> to formatter <code>ppf</code> labeling the header using function <code>pp_head</code>, the footer using <code>pp_foot</code>, the left side of rows using <code>pp_left</code>, and the right one using <code>pp_right</code>. A <code>pad</code>-option and context options can be passed.</p><p>If <code>None</code> is passed as argument for the default printers, the corresponding labels will not be printed.</p><dl><dt>parameter pp_head</dt><dd><p>default = <code>Some pp_int32_el</code></p></dd></dl><dl><dt>parameter pp_foot</dt><dd><p>default = <code>Some pp_int32_el</code></p></dd></dl><dl><dt>parameter pp_left</dt><dd><p>default = <code>Some pp_int32_el</code> for matrix rows (= not in header/footer row)</p></dd></dl><dl><dt>parameter pp_right</dt><dd><p>default = <code>Some pp_int32_el</code> for matrix rows (= not in header/footer row)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_labeled_fmat"><a href="#val-pp_labeled_fmat" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_fmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_mat">pp_labeled_mat</a></span></code></dt><dt class="spec value" id="val-pp_labeled_cmat"><a href="#val-pp_labeled_cmat" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_cmat : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_mat">pp_labeled_mat</a></span></code></dt><dt class="spec value" id="val-pp_labeled_imat"><a href="#val-pp_labeled_imat" class="anchor"></a><code><span class="keyword">val</span> pp_labeled_imat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_labeled_mat">pp_labeled_mat</a></span></code></dt></dl><dl><dt class="spec type" id="type-pp_lmat"><a href="#type-pp_lmat" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_lmat</span></code><code> = <span>?&#8288;print_head:bool</span> <span>&#45;&gt;</span> <span>?&#8288;print_foot:bool</span> <span>&#45;&gt;</span> <span>?&#8288;print_left:bool</span> <span>&#45;&gt;</span> <span>?&#8288;print_right:bool</span> <span>&#45;&gt;</span> <span>?&#8288;row_labels:<span>string array</span></span> <span>&#45;&gt;</span> <span>?&#8288;col_labels:<span>string array</span></span> <span>&#45;&gt;</span> <span>?&#8288;pad:<span>char option</span></span> <span>&#45;&gt;</span> <span>?&#8288;ellipsis:string</span> <span>&#45;&gt;</span> <span>?&#8288;vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array2.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of pretty-printers for string labeled matrices</p><p><code>pp_lmat ?print_head ?print_foot ?print_left ?print_right
      ?row_labels ?col_labels ?pad ?ellipsis
      ?vertical_context ?horizontal_context () ppf mat</code> prints a matrix <code>mat</code> to formatter <code>ppf</code> labeling the header with the column labels in <code>col_labels</code> if provided and if <code>print_head</code> is true, and labeling the footer with the column labels if <code>print_foot</code> is true. The left side of rows is labeled with the row labels <code>row_labels</code> if provided and if <code>print_left</code> is true, and the right side of rows is labeled with the row labels if <code>print_right</code> is true. A <code>pad</code>-option and context options can be passed.</p><p>It is the duty of the user to make sure that the arrays containing the row- and column labels are sufficiently large for the given matrix.</p><dl><dt>parameter print_head</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter print_foot</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter print_left</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter print_right</dt><dd><p>default = <code>true</code></p></dd></dl><dl><dt>parameter row_labels</dt><dd><p>default = no default (= no printing)</p></dd></dl><dl><dt>parameter col_labels</dt><dd><p>default = no default (= no printing)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_lfmat"><a href="#val-pp_lfmat" class="anchor"></a><code><span class="keyword">val</span> pp_lfmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lmat">pp_lmat</a></span></code></dt><dt class="spec value" id="val-pp_lcmat"><a href="#val-pp_lcmat" class="anchor"></a><code><span class="keyword">val</span> pp_lcmat : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lmat">pp_lmat</a></span></code></dt><dt class="spec value" id="val-pp_limat"><a href="#val-pp_limat" class="anchor"></a><code><span class="keyword">val</span> pp_limat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_lmat">pp_lmat</a></span></code></dt></dl></section><section><header><h6 id="pretty-printing-in-ocaml-style"><a href="#pretty-printing-in-ocaml-style" class="anchor"></a>Pretty-printing in OCaml-style</h6></header><dl><dt class="spec type" id="type-pp_el_ovec"><a href="#type-pp_el_ovec" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_el_ovec</span></code><code> = Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'el</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array1.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of pretty-printers for OCaml-vectors</p><p><code>pp_el_ovec ppf pp_el vec</code> prints the vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></dd></dl><dl><dt class="spec value" id="val-pp_ovec"><a href="#val-pp_ovec" class="anchor"></a><code><span class="keyword">val</span> pp_ovec : <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_el_ovec">pp_el_ovec</a></span></code></dt><dd><p><code>pp_ovec ppf pp_el vec</code> prints the column vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></dd></dl><dl><dt class="spec value" id="val-pp_rovec"><a href="#val-pp_rovec" class="anchor"></a><code><span class="keyword">val</span> pp_rovec : <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_el_ovec">pp_el_ovec</a></span></code></dt><dd><p><code>pp_rovec ppf pp_el vec</code> prints the row vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></dd></dl><dl><dt class="spec type" id="type-pp_ovec"><a href="#type-pp_ovec" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_ovec</span></code><code> = Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array1.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of pretty-printers for OCaml-vectors of a given element type</p><p><code>pp_ovec ppf vec</code> prints the vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style.</p></dd></dl><dl><dt class="spec value" id="val-pp_ofvec"><a href="#val-pp_ofvec" class="anchor"></a><code><span class="keyword">val</span> pp_ofvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_ovec">pp_ovec</a></span></code></dt><dt class="spec value" id="val-pp_ocvec"><a href="#val-pp_ocvec" class="anchor"></a><code><span class="keyword">val</span> pp_ocvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_ovec">pp_ovec</a></span></code></dt><dt class="spec value" id="val-pp_oivec"><a href="#val-pp_oivec" class="anchor"></a><code><span class="keyword">val</span> pp_oivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_ovec">pp_ovec</a></span></code></dt><dt class="spec value" id="val-pp_rofvec"><a href="#val-pp_rofvec" class="anchor"></a><code><span class="keyword">val</span> pp_rofvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_ovec">pp_ovec</a></span></code></dt><dt class="spec value" id="val-pp_rocvec"><a href="#val-pp_rocvec" class="anchor"></a><code><span class="keyword">val</span> pp_rocvec : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_ovec">pp_ovec</a></span></code></dt><dt class="spec value" id="val-pp_roivec"><a href="#val-pp_roivec" class="anchor"></a><code><span class="keyword">val</span> pp_roivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_ovec">pp_ovec</a></span></code></dt><dt class="spec value" id="val-pp_omat"><a href="#val-pp_omat" class="anchor"></a><code><span class="keyword">val</span> pp_omat : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'el</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'c</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array2.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_omat ppf pp_el mat</code> prints matrix <code>mat</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></dd></dl><dl><dt class="spec type" id="type-pp_omat"><a href="#type-pp_omat" class="anchor"></a><code><span class="keyword">type</span> <span>('el, 'elt) pp_omat</span></code><code> = Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, Stdlib.Bigarray.fortran_layout)</span> Stdlib.Bigarray.Array2.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of pretty-printers for OCaml-matrices of a given element type</p><p><code>pp_omat ppf mat</code> prints the matrix <code>mat</code> to formatter <code>ppf</code> in OCaml-style.</p></dd></dl><dl><dt class="spec value" id="val-pp_ofmat"><a href="#val-pp_ofmat" class="anchor"></a><code><span class="keyword">val</span> pp_ofmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_omat">pp_omat</a></span></code></dt><dt class="spec value" id="val-pp_ocmat"><a href="#val-pp_ocmat" class="anchor"></a><code><span class="keyword">val</span> pp_ocmat : <span><span>(Stdlib.Complex.t, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_omat">pp_omat</a></span></code></dt><dt class="spec value" id="val-pp_oimat"><a href="#val-pp_oimat" class="anchor"></a><code><span class="keyword">val</span> pp_oimat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="index.html#type-pp_omat">pp_omat</a></span></code></dt></dl></section><section><header><h6 id="good-pretty-printers-for-toplevels"><a href="#good-pretty-printers-for-toplevels" class="anchor"></a>Good pretty-printers for toplevels</h6></header><aside><p>These pretty-printers will use index labels for easier identification of rows and columns.</p></aside><div class="spec module" id="module-Toplevel"><a href="#module-Toplevel" class="anchor"></a><code><span class="keyword">module</span> <a href="Toplevel/index.html">Toplevel</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>