<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Io (lacaml.Lacaml.Io)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">lacaml</a> &#x00BB; <a href="../index.html">Lacaml</a> &#x00BB; Io</nav><header class="odoc-preamble"><h1>Module <code><span>Lacaml.Io</span></code></h1><p>Pretty-printing of vector and matrices.</p><p><code>Lacaml.Io</code>: generic matrix printing functions.</p></header><nav class="odoc-toc"><ul><li><a href="#default-pretty-printers-used-by-the-other-pretty-printing-functions">Default pretty-printers used by the other pretty-printing functions</a></li><li><a href="#pretty-printing-in-standard-style">Pretty-printing in standard style</a></li><li><a href="#labeled-pretty-printing">Labeled pretty-printing</a></li><li><a href="#vectors">Vectors</a></li><li><a href="#matrices">Matrices</a></li><li><a href="#pretty-printing-in-ocaml-style">Pretty-printing in OCaml-style</a></li><li><a href="#good-pretty-printers-for-toplevels">Good pretty-printers for toplevels</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Context"><a href="#module-Context" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Context/index.html">Context</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_mat_gen"><a href="#val-pp_mat_gen" class="anchor"></a><code><span><span class="keyword">val</span> pp_mat_gen : 
  <span>?pp_open:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_close:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_head:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_foot:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_end_row:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_end_col:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>row:int <span class="arrow">&#45;&gt;</span></span> <span>col:int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_left:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_right:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pad:<span>char option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?ellipsis:string <span class="arrow">&#45;&gt;</span></span>
  <span>?vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'el</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'a</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array2.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_mat_gen
       ?pp_open ?pp_close ?pp_head ?pp_foot ?pp_end_row ?pp_end_col
       ?pp_left ?pp_right ?pad pp_el ppf mat</code></p><p>Generic printing of matrices (two-dimensional bigarrays).</p><p><code>pp_open ppf</code> is called whenever printing of a matrix <code>mat</code> is started, <code>pp_close ppf</code> whenever printing is complete. These functions are not called when the matrix is empty.</p><p><code>pp_head other_ppf col</code> is used to print a header for column <code>col</code> in matrix <code>mat</code>. This header is right-aligned and eventually padded using <code>Some pad</code>-character to match the matrix rows in the column beneath. The passed formatter <code>other_ppf</code> is not identical to <code>ppf</code>!</p><p><code>pp_foot other_ppf col</code> is used to print a footer for column <code>col</code> in matrix <code>mat</code>. It is similar to <code>pp_head col other_ppf</code> otherwise.</p><p><code>pp_end_row ppf row</code> is called on row number <code>row</code> and formatter <code>ppf</code> whenever the end of a row has been reached.</p><p><code>pp_end_col ppf ~row ~col</code> is called on the row number <code>row</code>, column number <code>col</code> and formatter <code>ppf</code> whenever the element at this position has been printed and if it is not the last element in the row.</p><p><code>pp_left ppf row</code> is called on row number <code>row</code> and formatter <code>ppf</code> to print labels to the left of each row. The labels are right-aligned within a virtual column.</p><p><code>pp_right ppf row</code> is called on row number <code>row</code> and formatter <code>ppf</code> to print labels to the right of each row. The labels are left-aligned.</p><p>The character <code>pad</code> is used to pad matrix elements for right-aligning them appropriately. If it is set to <code>None</code>, no alignment will be performed.</p><p><code>ellipsis</code> is used as a filler when elements need to be skipped in the case of printing with contexts.</p><p><code>vertical_context</code> determines the number of initial and final rows to be printed. Intermediate row will be skipped, and one row containing ellipsis elements will be printed in their place instead. <code>None</code> chooses no context, <code>Some v</code> sets the vertical context to <code>v</code>.</p><p><code>horizontal_context</code> determines the number of initial and final columns to be printed. Intermediate columns will be skipped, and one columns containing ellipsis elements will be printed in their place instead. <code>None</code> chooses no context, <code>Some h</code> sets the horizontal context to <code>h</code>.</p><p><code>pp_el other_ppf el</code> is called on formatter <code>other_ppf</code> (not <code>ppf</code>!) and each matrix element.</p><p><code>ppf</code> is the formatter to which all output is finally printed.</p><p><code>mat</code> is the matrix to be printed.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_open</span> <p>default = open standard pretty-printing box</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_close</span> <p>default = close standard pretty-printing box</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_head</span> <p>default = no default</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_foot</span> <p>default = no default</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_end_row</span> <p>default = print newline (within pretty-printing box)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_end_col</span> <p>default = print space</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_left</span> <p>default = no default</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pad</span> <p>default = <code>Some ' '</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ellipsis</span> <p>default = <code>!Context.ellipsis</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">vertical_context</span> <p>default = <code>Some !Context.vertical_default</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">horizontal_context</span> <p>default = <code>Some !Context.horizontal_default</code></p></li></ul></div></div><h6 id="default-pretty-printers-used-by-the-other-pretty-printing-functions"><a href="#default-pretty-printers-used-by-the-other-pretty-printing-functions" class="anchor"></a>Default pretty-printers used by the other pretty-printing functions</h6><div class="odoc-spec"><div class="spec type anchored" id="type-pp_el_default"><a href="#type-pp_el_default" class="anchor"></a><code><span><span class="keyword">type</span> <span>'el pp_el_default</span></span><span> = <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'el</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Type of references for default printers of elements</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_float_el_default"><a href="#val-pp_float_el_default" class="anchor"></a><code><span><span class="keyword">val</span> pp_float_el_default : <span>float <a href="#type-pp_el_default">pp_el_default</a></span></span></code></div><div class="spec-doc"><p>fprintf ppf &quot;%G&quot; el</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_complex_el_default"><a href="#val-pp_complex_el_default" class="anchor"></a><code><span><span class="keyword">val</span> pp_complex_el_default : <span><span class="xref-unresolved">Stdlib</span>.Complex.t <a href="#type-pp_el_default">pp_el_default</a></span></span></code></div><div class="spec-doc"><p>fprintf ppf &quot;(%G, %Gi)&quot; el.re el.im</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_int32_el"><a href="#val-pp_int32_el" class="anchor"></a><code><span><span class="keyword">val</span> pp_int32_el : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>fprintf ppf &quot;%ld&quot; el</p></div></div><h6 id="pretty-printing-in-standard-style"><a href="#pretty-printing-in-standard-style" class="anchor"></a>Pretty-printing in standard style</h6><div class="odoc-spec"><div class="spec type anchored" id="type-pp_vec"><a href="#type-pp_vec" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_vec</span></span><span> =
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of standard pretty-printers for column vectors</p><p><code>pp_vec ppf vec</code> prints a vector <code>vec</code> to formatter <code>ppf</code> using the defaults.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_fvec"><a href="#val-pp_fvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_fvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_vec">pp_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_cvec"><a href="#val-pp_cvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_cvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_vec">pp_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_ivec"><a href="#val-pp_ivec" class="anchor"></a><code><span><span class="keyword">val</span> pp_ivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_vec">pp_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rfvec"><a href="#val-pp_rfvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_vec">pp_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rcvec"><a href="#val-pp_rcvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rcvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_vec">pp_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rivec"><a href="#val-pp_rivec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_vec">pp_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pp_mat"><a href="#type-pp_mat" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_mat</span></span><span> =
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array2.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of standard pretty-printers for matrices</p><p><code>pp_mat ppf mat</code> prints a matrix <code>mat</code> to formatter <code>ppf</code> using the defaults.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_fmat"><a href="#val-pp_fmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_fmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_mat">pp_mat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_cmat"><a href="#val-pp_cmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_cmat : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_mat">pp_mat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_imat"><a href="#val-pp_imat" class="anchor"></a><code><span><span class="keyword">val</span> pp_imat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_mat">pp_mat</a></span></span></code></div></div><h6 id="labeled-pretty-printing"><a href="#labeled-pretty-printing" class="anchor"></a>Labeled pretty-printing</h6><h6 id="vectors"><a href="#vectors" class="anchor"></a>Vectors</h6><div class="odoc-spec"><div class="spec type anchored" id="type-pp_labeled_vec"><a href="#type-pp_labeled_vec" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_labeled_vec</span></span><span> =
  <span>?pp_head:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_foot:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_left:<span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_right:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pad:<span>char option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?ellipsis:string <span class="arrow">&#45;&gt;</span></span>
  <span>?vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of pretty-printers for labeled vectors</p><p><code>pp_labeled_vec ?pp_head ?pp_foot ?pp_left ?pp_right ?pad
      ?ellipsis ?vertical_context ?horizontal_context () ppf vec</code> prints vector <code>vec</code> to formatter <code>ppf</code> labeling the header using function <code>pp_head</code>, the footer using <code>pp_foot</code>, the left side (of rows for column vectors; of columns for row vectors) using <code>pp_left</code>, and the right side using <code>pp_right</code>. A <code>pad</code>-option and context options can be passed.</p><p>For column vectors the labels on the left side are right-aligned while those on the right side are left-aligned.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_head</span> <p>default = no default (= no printing)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_foot</span> <p>default = no default (= no printing)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_left</span> <p>default = <code>Some pp_int32_el</code> for vector rows/cols (= not in header/footer row/col)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_right</span> <p>default = no default (= no printing)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_fvec"><a href="#val-pp_labeled_fvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_fvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_vec">pp_labeled_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_cvec"><a href="#val-pp_labeled_cvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_cvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_vec">pp_labeled_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_ivec"><a href="#val-pp_labeled_ivec" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_ivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_vec">pp_labeled_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_rfvec"><a href="#val-pp_labeled_rfvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_rfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_vec">pp_labeled_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_rcvec"><a href="#val-pp_labeled_rcvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_rcvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_vec">pp_labeled_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_rivec"><a href="#val-pp_labeled_rivec" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_rivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_vec">pp_labeled_vec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pp_lvec"><a href="#type-pp_lvec" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_lvec</span></span><span> =
  <span>?print_head:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?print_foot:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?print_left:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?print_right:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?labels:<span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?name:string <span class="arrow">&#45;&gt;</span></span>
  <span>?pad:<span>char option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?ellipsis:string <span class="arrow">&#45;&gt;</span></span>
  <span>?vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of pretty-printers for string labeled vectors</p><p><code>pp_lvec ?print_head ?print_foot ?print_left ?print_right
      ?labels ?name ?pad ?ellipsis ?vertical_context ?horizontal_context
      () ppf vec</code> prints vector <code>vec</code> to formatter <code>ppf</code> labeling the header with <code>name</code> if provided and if <code>print_head</code> is true, and labeling the footer with <code>name</code> if <code>print_foot</code> is true. The left side (of rows for column vectors; of columns for row vectors) is labeled with <code>labels</code> if provided and if <code>print_left</code> is true, and the right side is labeled with <code>labels</code> if <code>print_right</code> is true. A <code>pad</code>-option and context options can be passed.</p><p>For columns vectors the labels on the left side are right-aligned while those on the right side are left-aligned.</p><p>It is the duty of the user to make sure that the array containing the labels is sufficiently large for the given vector.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_head</span> <p>default = <code>true</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_foot</span> <p>default = <code>true</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_left</span> <p>default = <code>true</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_right</span> <p>default = <code>false</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">labels</span> <p>default = no default (= no printing)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">header</span> <p>default = no default (= no printing)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_lfvec"><a href="#val-pp_lfvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_lfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lvec">pp_lvec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_lcvec"><a href="#val-pp_lcvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_lcvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lvec">pp_lvec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_livec"><a href="#val-pp_livec" class="anchor"></a><code><span><span class="keyword">val</span> pp_livec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lvec">pp_lvec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rlfvec"><a href="#val-pp_rlfvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rlfvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lvec">pp_lvec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rlcvec"><a href="#val-pp_rlcvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rlcvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lvec">pp_lvec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rlivec"><a href="#val-pp_rlivec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rlivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lvec">pp_lvec</a></span></span></code></div></div><h6 id="matrices"><a href="#matrices" class="anchor"></a>Matrices</h6><div class="odoc-spec"><div class="spec type anchored" id="type-pp_labeled_mat"><a href="#type-pp_labeled_mat" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_labeled_mat</span></span><span> =
  <span>?pp_head:<span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_foot:<span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_left:<span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pp_right:<span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pad:<span>char option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?ellipsis:string <span class="arrow">&#45;&gt;</span></span>
  <span>?vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array2.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of pretty-printers for labeled matrices</p><p><code>pp_labeled_mat ?pp_head ?pp_foot ?pp_left ?pp_right ?pad
      ?ellipsis ?vertical_context ?horizontal_context () ppf mat</code> prints a matrix <code>mat</code> to formatter <code>ppf</code> labeling the header using function <code>pp_head</code>, the footer using <code>pp_foot</code>, the left side of rows using <code>pp_left</code>, and the right one using <code>pp_right</code>. A <code>pad</code>-option and context options can be passed.</p><p>If <code>None</code> is passed as argument for the default printers, the corresponding labels will not be printed.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_head</span> <p>default = <code>Some pp_int32_el</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_foot</span> <p>default = <code>Some pp_int32_el</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_left</span> <p>default = <code>Some pp_int32_el</code> for matrix rows (= not in header/footer row)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pp_right</span> <p>default = <code>Some pp_int32_el</code> for matrix rows (= not in header/footer row)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_fmat"><a href="#val-pp_labeled_fmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_fmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_mat">pp_labeled_mat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_cmat"><a href="#val-pp_labeled_cmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_cmat : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_mat">pp_labeled_mat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_labeled_imat"><a href="#val-pp_labeled_imat" class="anchor"></a><code><span><span class="keyword">val</span> pp_labeled_imat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_labeled_mat">pp_labeled_mat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pp_lmat"><a href="#type-pp_lmat" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_lmat</span></span><span> =
  <span>?print_head:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?print_foot:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?print_left:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?print_right:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?row_labels:<span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?col_labels:<span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?pad:<span>char option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?ellipsis:string <span class="arrow">&#45;&gt;</span></span>
  <span>?vertical_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?horizontal_context:<span><a href="Context/index.html#type-t">Context.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array2.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of pretty-printers for string labeled matrices</p><p><code>pp_lmat ?print_head ?print_foot ?print_left ?print_right
      ?row_labels ?col_labels ?pad ?ellipsis
      ?vertical_context ?horizontal_context () ppf mat</code> prints a matrix <code>mat</code> to formatter <code>ppf</code> labeling the header with the column labels in <code>col_labels</code> if provided and if <code>print_head</code> is true, and labeling the footer with the column labels if <code>print_foot</code> is true. The left side of rows is labeled with the row labels <code>row_labels</code> if provided and if <code>print_left</code> is true, and the right side of rows is labeled with the row labels if <code>print_right</code> is true. A <code>pad</code>-option and context options can be passed.</p><p>It is the duty of the user to make sure that the arrays containing the row- and column labels are sufficiently large for the given matrix.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_head</span> <p>default = <code>true</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_foot</span> <p>default = <code>true</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_left</span> <p>default = <code>true</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">print_right</span> <p>default = <code>true</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">row_labels</span> <p>default = no default (= no printing)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">col_labels</span> <p>default = no default (= no printing)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_lfmat"><a href="#val-pp_lfmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_lfmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lmat">pp_lmat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_lcmat"><a href="#val-pp_lcmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_lcmat : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lmat">pp_lmat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_limat"><a href="#val-pp_limat" class="anchor"></a><code><span><span class="keyword">val</span> pp_limat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_lmat">pp_lmat</a></span></span></code></div></div><h6 id="pretty-printing-in-ocaml-style"><a href="#pretty-printing-in-ocaml-style" class="anchor"></a>Pretty-printing in OCaml-style</h6><div class="odoc-spec"><div class="spec type anchored" id="type-pp_el_ovec"><a href="#type-pp_el_ovec" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_el_ovec</span></span><span> =
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'el</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of pretty-printers for OCaml-vectors</p><p><code>pp_el_ovec ppf pp_el vec</code> prints the vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_ovec"><a href="#val-pp_ovec" class="anchor"></a><code><span><span class="keyword">val</span> pp_ovec : <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>)</span> <a href="#type-pp_el_ovec">pp_el_ovec</a></span></span></code></div><div class="spec-doc"><p><code>pp_ovec ppf pp_el vec</code> prints the column vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rovec"><a href="#val-pp_rovec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rovec : <span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>)</span> <a href="#type-pp_el_ovec">pp_el_ovec</a></span></span></code></div><div class="spec-doc"><p><code>pp_rovec ppf pp_el vec</code> prints the row vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pp_ovec"><a href="#type-pp_ovec" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_ovec</span></span><span> =
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of pretty-printers for OCaml-vectors of a given element type</p><p><code>pp_ovec ppf vec</code> prints the vector <code>vec</code> to formatter <code>ppf</code> in OCaml-style.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_ofvec"><a href="#val-pp_ofvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_ofvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_ovec">pp_ovec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_ocvec"><a href="#val-pp_ocvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_ocvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_ovec">pp_ovec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_oivec"><a href="#val-pp_oivec" class="anchor"></a><code><span><span class="keyword">val</span> pp_oivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_ovec">pp_ovec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rofvec"><a href="#val-pp_rofvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rofvec : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_ovec">pp_ovec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_rocvec"><a href="#val-pp_rocvec" class="anchor"></a><code><span><span class="keyword">val</span> pp_rocvec : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_ovec">pp_ovec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_roivec"><a href="#val-pp_roivec" class="anchor"></a><code><span><span class="keyword">val</span> pp_roivec : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_ovec">pp_ovec</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_omat"><a href="#val-pp_omat" class="anchor"></a><code><span><span class="keyword">val</span> pp_omat : 
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'el</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'c</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array2.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_omat ppf pp_el mat</code> prints matrix <code>mat</code> to formatter <code>ppf</code> in OCaml-style using the element printer <code>pp_el</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pp_omat"><a href="#type-pp_omat" class="anchor"></a><code><span><span class="keyword">type</span> <span>('el, 'elt) pp_omat</span></span><span> =
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'el</span>, <span class="type-var">'elt</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.fortran_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array2.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Type of pretty-printers for OCaml-matrices of a given element type</p><p><code>pp_omat ppf mat</code> prints the matrix <code>mat</code> to formatter <code>ppf</code> in OCaml-style.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_ofmat"><a href="#val-pp_ofmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_ofmat : <span><span>(float, <span class="type-var">'elt</span>)</span> <a href="#type-pp_omat">pp_omat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_ocmat"><a href="#val-pp_ocmat" class="anchor"></a><code><span><span class="keyword">val</span> pp_ocmat : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'elt</span>)</span> <a href="#type-pp_omat">pp_omat</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_oimat"><a href="#val-pp_oimat" class="anchor"></a><code><span><span class="keyword">val</span> pp_oimat : <span><span>(int32, <span class="type-var">'elt</span>)</span> <a href="#type-pp_omat">pp_omat</a></span></span></code></div></div><h6 id="good-pretty-printers-for-toplevels"><a href="#good-pretty-printers-for-toplevels" class="anchor"></a>Good pretty-printers for toplevels</h6><p>These pretty-printers will use index labels for easier identification of rows and columns.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Toplevel"><a href="#module-Toplevel" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Toplevel/index.html">Toplevel</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>