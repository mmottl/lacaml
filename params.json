{"name":"Lacaml","tagline":"OCaml bindings for BLAS/LAPACK (high-performance linear algebra Fortran libraries)","body":"LACAML - Linear Algebra for OCaml\r\n=================================\r\n\r\n---------------------------------------------------------------------------\r\n\r\nWhat is LACAML?\r\n---------------\r\n\r\nThis [OCaml](http://www.ocaml.org)-library interfaces two widely used\r\nmathematical FORTRAN-libraries:\r\n\r\n  * [BLAS - Basic Linear Algebra Subroutines](http://www.netlib.org/blas/index.html)\r\n  * [LAPACK - Linear Algebra PACKage](http://www.netlib.org/lapack/index.html)\r\n\r\nThis allows developers to write high-performance numerical code for\r\napplications that require linear algebra.\r\n\r\nFeatures\r\n--------\r\n\r\n  * The BLAS- and LAPACK-libraries have evolved over about two decades of\r\n    time and are therefore extremely mature both in terms of stability\r\n    and performance.\r\n\r\n  * LACAML interfaces most of the functions in BLAS and LAPACK (many\r\n    hundreds!).  It supports among other things linear equations, least\r\n    squares problems, eigenvalue problems, singular value decomposition\r\n    (SVD), Cholesky and QR-factorization, etc.\r\n\r\n  * Many convenience functions for creating and manipulating matrices.\r\n\r\n  * Powerful printing functions for large vectors and matrices and supplemental\r\n    information (e.g. row and column headers).  Users can specify easily how\r\n    much context to print.  For example, it is usually sufficient to print\r\n    small blocks of the four corners of a large result matrix to manually\r\n    verify the correctness of an algorithm.  LACAML uses this approach to\r\n    limit the output to human-manageable size.\r\n\r\n  * Integration into the OCaml-toplevel allows for easy experimentation for\r\n    students and researchers as well as demonstration for lecturers.\r\n    Values of vector and matrix type will be printed automatically without\r\n    cluttering the screen.\r\n\r\n  * The OCaml-interface was designed in a way to combine both the possibility\r\n    of gaining optimum efficiency (e.g. by allowing the creation of work arrays\r\n    outside of loops) with simplicity (thanks to labels and default arguments).\r\n\r\n  * The code is precision-independent and supports both real and complex\r\n    transforms in a consistent way.  There are four modules that implement\r\n    the same interface modulo the precision type and specialized real/complex\r\n    functions.  If you refer to elements in this interface only, your code\r\n    becomes precision- and (if meaningful) real/complex independent, too:\r\n    you can choose at anytime whether you want to use single-precision or\r\n    double-precision simply by referring to the required module.\r\n\r\n  * You can fully exploit the library within multithreaded programs.  Many\r\n    numerical routines are likely to run for a long time, but they will never\r\n    block other threads.  This also means that you can execute several routines\r\n    at the same time on several processors if you use POSIX-threads in OCaml.\r\n\r\n  * To make things easy for developers used to the \"real\" implementation\r\n    in FORTRAN but also for beginners who need detailed documentation, both\r\n    function- and argument names have been kept compatible to the ones used\r\n    in the BLAS- and LAPACK-documentation.  Only exception: you need not\r\n    prefix functions with `s`, `d`, `c` or `z` to indicate the precision\r\n    and type of numbers, because the OCaml module system provides us with\r\n    a more convenient means of choosing them.\r\n\r\n  * (Almost) all errors are handled within OCaml.  Typical mistakes like\r\n    passing non-conforming matrices, parameters that are out of range, etc.,\r\n    will be caught before calling Fortran code and will raise exceptions.\r\n    These exceptions will explain the error in detail, for example the\r\n    received illegal parameter and the range of expected legal values.\r\n\r\n    The only exception to the above is illegal contents of vectors and\r\n    matrices.  This can happen, for example, when freshly allocated matrices\r\n    are used without initialization.  Some LAPACK-algorithms may not be able\r\n    to deal with floats that correspond to NaNs, infinities, or are subnormal.\r\n    Checking matrices on every call would seem excessive.  Some functions\r\n    also expect matrices with certain properties, e.g. positive-definiteness,\r\n    which would be way too costly to verify beforehand.  It is the task of\r\n    the user to make sure that data contained in matrices is suitable for\r\n    the application of the intended functions.\r\n\r\n---------------------------------------------------------------------------\r\n\r\nUsing LACAML\r\n------------\r\n\r\nYou can make use of this library by referring to the corresponding module\r\nfor the required precision and number type.  E.g.:\r\n\r\n```ocaml\r\nopen Lacaml.S  (* Single-precision real numbers *)\r\nopen Lacaml.D  (* Double-precision real numbers *)\r\nopen Lacaml.C  (* Single-precision complex numbers *)\r\nopen Lacaml.Z  (* Double-precision complex numbers *)\r\n```\r\n\r\nThese modules become available if you link the `lacaml`-library with your\r\napplication.  The widely used OCaml-tool `findlib` will take care of linking\r\n`lacaml` correctly.  If you do not use this tool, you will also have to link\r\nin the `bigarray`-library provided by the OCaml-distribution.\r\n\r\nThe `Lacaml.?`-modules implement the BLAS/LAPACK-interface.  Their\r\ncorresponding submodules `Vec` and `Mat` provide for vector and matrix\r\noperations that relate to the given precision and number type.\r\n\r\nMost functions were implemented using optional arguments (= default arguments).\r\nIf you do not provide them at the call-site, sane defaults will be used\r\ninstead.  Here is an example of a function call:\r\n\r\n```ocaml\r\nlet rank = gelss in_mat out_mat in\r\n(* ... *)\r\n```\r\n\r\nThis example computes the solution to a general least squares problem (=\r\nlinear regression) using the SVD-algorithm with `in_mat` as the matrix\r\ncontaining the predictor variables and `out_mat` as the matrix containing\r\n(possibly many) response variables (this function can handle several response\r\nvariables at once).  The result is the rank of the matrix.  The matrices\r\nprovided in the arguments will be overwritten with further results (here:\r\nthe singular vectors and the solution matrix).\r\n\r\nIf the above happened in a loop, this would be slightly inefficient, because\r\na work-array would have to be allocated (and later deallocated) at each call.\r\nYou can hoist the creation of this work array out of the loop, e.g. (`m`,\r\n`n`, `nrhs` are problem dependent parameters):\r\n\r\n```ocaml\r\nlet work = gelss_min_work ~m ~n ~nrhs in\r\nfor i = 1 to 1000 do\r\n  (* ... *)\r\n  let rank = gelss in_mat ~work out_mat in\r\n  (* ... *)\r\ndone\r\n```\r\n\r\nAll matrices can be accessed in a restricted way, i.e. you can specify\r\nsubmatrices for all matrix parameters.  For example, if some matrix is called\r\n`a` in the interface documentation, you can specify the left upper corner of\r\nthe wanted submatrix for the operation by setting `ar` for the row and `ac`\r\nfor the column (1 by default).  A vector `y` would have an extra optional\r\nparameter `ofsy` (also 1 by default).  Parameters like `m` or `n` typically\r\nspecify the numbers of rows or columns.\r\n\r\n### Printing vectors and matrices\r\n\r\nHere is a toplevel example of printing a large random matrix:\r\n\r\n```ocaml\r\n# #require \"lacaml\";;\r\n# open Lacaml.D;;\r\n# let mat = Mat.random 100 200;;\r\nval mat : Lacaml.D.mat =\r\n              C1        C2        C3          C198       C199      C200\r\n    R1 -0.314362 -0.530711  0.309887 ...  0.519965  -0.230156 0.0479154\r\n    R2  0.835658  0.581404  0.161607 ... -0.749358  -0.630019 -0.858998\r\n    R3 -0.403421  0.458116 -0.497516 ...  0.210811   0.422094  0.589661\r\n             ...       ...       ... ...       ...        ...       ...\r\n   R98 -0.352474  0.878897  0.357842 ...  0.150786   -0.74011  0.353253\r\n   R99  0.104805  0.984924 -0.319127 ... -0.143679  -0.858269  0.859059\r\n  R100  0.419968  0.333358  0.237761 ... -0.483535 -0.0224016  0.513944\r\n```\r\n\r\nOnly the corner sections of the matrix, which would otherwise be too large\r\nto display readably, are being printed, and ellipses (`...`) are used in\r\nplace of the removed parts of the matrix.\r\n\r\nIf the user required even less context, the `Lacaml.Io.Toplevel.lsc` function,\r\nwhich is also available in each precision module for convenience (here:\r\n`Lacaml.D`), could be used to indicate how much.  In the following example\r\nonly two-by-two blocks are requested in each corner of the matrix:\r\n\r\n```ocaml\r\n# lsc 2;;\r\n- : unit = ()\r\n# mat;;\r\n- : Lacaml.D.mat =\r\n            C1        C2           C199      C200\r\n  R1 -0.314362 -0.530711 ...  -0.230156 0.0479154\r\n  R2  0.835658  0.581404 ...  -0.630019 -0.858998\r\n           ...       ... ...        ...       ...\r\n R99  0.104805  0.984924 ...  -0.858269  0.859059\r\nR100  0.419968  0.333358 ... -0.0224016  0.513944\r\n```\r\n\r\nApplications can use the standard `Format`-module in the OCaml-distribution\r\ntogether with LACAML printing functions to output vectors and matrices.\r\nHere is an example using labels and showing the high customizability of the\r\nprinting functions:\r\n\r\n```ocaml\r\nopen Lacaml.D\r\nopen Lacaml.Io\r\n\r\nlet () =\r\n  let rows, cols = 200, 100 in\r\n  let a = Mat.random rows cols in\r\n  Format.printf \"@[<2>This is an indented random matrix:@\\n@\\n%a@]@.\"\r\n    (Lacaml.Io.pp_lfmat\r\n      ~row_labels:\r\n        (Array.init rows (fun i -> Printf.sprintf \"Row %d\" (i + 1)))\r\n      ~col_labels:\r\n        (Array.init cols (fun i -> Printf.sprintf \"Col %d\" (i + 1)))\r\n      ~vertical_context:(Some (Context.create 2))\r\n      ~horizontal_context:(Some (Context.create 3))\r\n      ~ellipsis:\"*\"\r\n      ~print_right:false\r\n      ~print_foot:false ())\r\n    a\r\n```\r\n\r\nThe above code might print:\r\n\r\n```text\r\nThis is an indented random matrix:\r\n\r\n              Col 1     Col 2       Col 3      Col 98    Col 99   Col 100\r\n    Row 1  0.852078 -0.316723    0.195646 *  0.513697  0.656419  0.545189\r\n    Row 2 -0.606197  0.411059    0.158064 * -0.368989    0.2174    0.9001\r\n                  *         *           * *         *         *         *\r\n  Row 199 -0.684374 -0.939027 0.000699582 *  0.117598 -0.285587 -0.654935\r\n  Row 200  0.929341 -0.823264    0.895798 *  0.198334  0.725029 -0.621723\r\n```\r\n\r\nMany other options, e.g. for different padding, printing numbers in\r\nother formats or with different precision, etc., are available for output\r\ncustomization.\r\n\r\n### Other sources of usage information\r\n\r\n#### API documentation\r\n\r\nPlease refer to the API-documentation that will be generated as HTML-files\r\nif requested (`make doc`).  It will give more details on the numerous\r\nfunctions and supported arguments in the library.  It can also be found\r\n[online](http://mmottl.github.io/lacaml/api).\r\n\r\n#### BLAS/LAPACK man pages\r\n\r\nBLAS and LAPACK binary packages for Unix operating systems usually come\r\nwith appropriate man-pages.  E.g. to quickly look up how to factorize a\r\npositive-definite, complex, single precision matrix, you might enter:\r\n\r\n```sh\r\nman cpotrf\r\n```\r\n\r\nThe corresponding function in Lacaml would be `Lacaml.C.potrf`.  The naming\r\nconventions and additional documentation for BLAS and LAPACK can be found\r\nat their respective websites.\r\n\r\n#### Examples\r\n\r\nThe `examples`-directory contains several demonstrations of how to use this\r\nlibrary for various linear algebra problems.\r\n\r\nImproving Performance\r\n---------------------\r\n\r\nIt is highly recommended that users install a variant of BLAS (or even\r\nLAPACK) that has been optimized for their system.  Processor vendors\r\n(e.g. Intel) usually sell the most optimized implementations for their\r\nCPU-architectures.  Some computer and OS-vendors like Apple distribute their\r\nown implementations with their products, e.g. `vecLib`, which is part of\r\nApple's `Accelerate`-framework.\r\n\r\nThere is also [ATLAS](http://www.netlib.org/atlas), a very efficient and\r\ncompatible substitute for BLAS.  It specializes code for the architecture it\r\nis compiled on.  Binary packages (e.g. RPMs) for Linux should be available\r\nfrom your distribution vendor's site (you must recompile the package to\r\nmake sure it is suited to your distribution, see the package documentation\r\nfor more details.).  \r\n\r\nAnother alternative for BLAS is [OpenBLAS](https://github.com/xianyi/OpenBLAS).\r\n\r\n---------------------------------------------------------------------------\r\n\r\nContact Information and Contributing\r\n------------------------------------\r\n\r\nIn the case of bugs, feature requests, contributions and similar, please\r\ncontact the maintainers:\r\n\r\n  * Markus Mottl <markus.mottl@gmail.com>\r\n  * Christophe Troestler <Christophe.Troestler@umons.ac.be>\r\n\r\nUp-to-date information concerning this tool should be available at:\r\n<https://mmottl.github.io/lacaml>\r\n\r\nEnjoy!\r\n\r\nMarkus Mottl in Rutherford, NJ on July 9, 2012\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}